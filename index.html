<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Тест микрофона и Распознавание речи</title>
<style>
    body { font-family: Arial, sans-serif; display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0; background: #f0f2f5; }
    .container { text-align: center; background: #fff; padding: 25px; border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); width: 90%; max-width: 500px; }
    h1 { margin: 0; }
    #status { margin: 15px 0; font-weight: bold; }
    .status-success { color: #2ecc71; }
    .status-error { color: #e74c3c; }
    .status-warning { color: #f39c12; }
    .volume-meter { width: 100%; max-width: 300px; height: 30px; border: 1px solid #ccc; border-radius: 8px; overflow: hidden; margin: 15px auto; background: #e9ecef; }
    #volume-level { height: 100%; width: 0%; background: #2ecc71; transition: width 0.1s linear; }
    .recognition-output { margin-top: 20px; }
    #recognition-result { font-size: 2em; font-weight: bold; color: #34495e; min-height: 1.2em; } /* Добавлена минимальная высота для стабильности */
    button { margin-top: 20px; padding: 12px 25px; font-size: 1.1em; background: #3498db; color: white; border: none; border-radius: 8px; cursor: pointer; }
    button.stop-btn { background: #e74c3c; }
    .info-box { font-size: 0.9em; margin-top: 15px; background: #f7f7f7; padding: 10px; border-radius: 8px; text-align: left; }
    .download-link { display: block; margin-top: 10px; color: #2980b9; font-weight: bold; }
</style>
</head>
<body>
<div class="container">
    <h1>Тест микрофона и речи</h1>
    <p>Скажите "Да" или "Нет". Если распознавание не сработает — будет fallback запись.</p>
    <p id="status">Ожидание проверки...</p>
    <div class="volume-meter"><div id="volume-level"></div></div>
    <div class="recognition-output"><p id="recognition-result"></p></div>
    <button id="checkMicBtn">Проверить микрофон</button>
    <div class="info-box" id="supportInfo"></div>
    <a id="downloadLink" class="download-link" style="display:none;">Скачать запись (WAV)</a>
</div>

<script>
const checkMicBtn = document.getElementById('checkMicBtn');
const statusEl = document.getElementById('status');
const volumeLevelEl = document.getElementById('volume-level');
const recognitionResultEl = document.getElementById('recognition-result');
const supportInfo = document.getElementById('supportInfo');
const downloadLink = document.getElementById('downloadLink');

let audioContext, analyser, microphone, animationFrameId;
let isListening = false;
let mediaRecorder, audioChunks = [];

const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
let recognition;
const userAgent = navigator.userAgent;

// Показываем инфо о поддержке
if (SpeechRecognition) {
    supportInfo.innerHTML = `✅ Web Speech API доступен.<br>UA: ${userAgent}`;
    recognition = new SpeechRecognition();
    recognition.lang = 'ru-RU';
    recognition.continuous = true; // Важно для постоянного прослушивания
    recognition.interimResults = false;

    recognition.onresult = (event) => {
        const lastResult = event.results[event.results.length - 1];
        const command = lastResult[0].transcript.trim().toLowerCase();
        console.log('Распознано:', command); // Для отладки
        
        // Используем includes для более гибкого поиска
        if (command.includes('да')) {
            recognitionResultEl.textContent = 'Да';
        } else if (command.includes('нет')) {
            recognitionResultEl.textContent = 'Нет';
        } else {
            // Можно показывать и другие слова, если нужно
            recognitionResultEl.textContent = command.charAt(0).toUpperCase() + command.slice(1);
        }
    };

    recognition.onerror = (event) => {
        console.error('Ошибка распознавания:', event.error);
        // Если это не ошибка 'no-speech', которая возникает при молчании
        if (event.error !== 'no-speech') {
            statusEl.textContent = 'Ошибка распознавания: ' + event.error;
            statusEl.className = 'status-warning';
            // Если произошла серьезная ошибка (например, сеть), переключаемся на запись
            if (event.error === 'network' || event.error === 'service-not-allowed') {
                recognition.stop();
                startFallbackRecording();
            }
        }
    };

    // КЛЮЧЕВОЙ МОМЕНТ ДЛЯ ANDROID:
    // API на мобильных устройствах часто "засыпает" или прекращает работу.
    // Этот обработчик перезапускает его, пока мы находимся в режиме прослушивания.
    recognition.onend = () => {
        if (isListening) {
            console.log("Распознавание завершилось, перезапускаю...");
            recognition.start();
        }
    };
} else {
    supportInfo.innerHTML = `❌ Web Speech API не поддерживается.<br>UA: ${userAgent}<br>Используем fallback запись.`;
}

async function startMicCheck() {
    if (isListening) return;
    try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        window.stream = stream;

        isListening = true; // Устанавливаем флаг сразу после получения доступа
        checkMicBtn.textContent = 'Остановить проверку';
        checkMicBtn.classList.add('stop-btn');
        recognitionResultEl.textContent = '...';

        statusEl.textContent = '✓ Микрофон активен. Говорите!';
        statusEl.className = 'status-success';

        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        analyser = audioContext.createAnalyser();
        microphone = audioContext.createMediaStreamSource(stream);
        microphone.connect(analyser);
        analyser.fftSize = 256;
        drawVolume();

        // --- ГЛАВНОЕ ИЗМЕНЕНИЕ ЗДЕСЬ ---
        // Пытаемся запустить распознавание, если оно поддерживается.
        // Убрана проверка `!isAndroid`, чтобы разрешить работу на Android.
        if (recognition) {
            try {
                recognition.start();
            } catch (e) {
                console.error('Не удалось запустить распознавание, переключаемся на fallback:', e);
                startFallbackRecording();
            }
        } else {
            // Если SpeechRecognition API вообще не поддерживается
            startFallbackRecording();
        }

    } catch (err) {
        console.error("Ошибка доступа к микрофону:", err);
        statusEl.textContent = 'Ошибка доступа к микрофону: ' + err.message;
        statusEl.className = 'status-error';
    }
}

function startFallbackRecording() {
    statusEl.textContent = 'Распознавание недоступно. Включена запись (fallback).';
    statusEl.className = 'status-warning';

    // Убедимся, что поток существует
    if (!window.stream) {
        console.error("Невозможно начать запись: аудиопоток отсутствует.");
        statusEl.textContent = "Ошибка: аудиопоток не найден для записи.";
        statusEl.className = "status-error";
        return;
    }

    mediaRecorder = new MediaRecorder(window.stream);
    audioChunks = [];
    mediaRecorder.ondataavailable = (e) => audioChunks.push(e.data);
    mediaRecorder.onstop = () => {
        const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
        const audioUrl = URL.createObjectURL(audioBlob);
        downloadLink.href = audioUrl;
        downloadLink.download = 'record.wav';
        downloadLink.style.display = 'block';
    };
    mediaRecorder.start();
}

function stopMicCheck() {
    if (!isListening) return;
    isListening = false; // Сбрасываем флаг в самом начале

    // Это предотвратит автоматический перезапуск в обработчике onend
    if (recognition) {
        recognition.stop();
    }
    
    if (mediaRecorder && mediaRecorder.state !== 'inactive') {
        mediaRecorder.stop();
    }

    if (window.stream) {
        window.stream.getTracks().forEach(track => track.stop());
        window.stream = null;
    }
    if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
    }
    if (audioContext) {
        audioContext.close();
        audioContext = null;
    }

    statusEl.textContent = 'Ожидание проверки...';
    statusEl.className = '';
    volumeLevelEl.style.width = '0%';
    checkMicBtn.textContent = 'Проверить микрофон';
    checkMicBtn.classList.remove('stop-btn');
    recognitionResultEl.textContent = '';
    downloadLink.style.display = 'none'; // Прячем ссылку на скачивание
}

function drawVolume() {
    const dataArray = new Uint8Array(analyser.frequencyBinCount);
    const update = () => {
        if (!isListening) return; // Прекращаем отрисовку, если остановили
        analyser.getByteFrequencyData(dataArray);
        let sum = dataArray.reduce((a, b) => a + b, 0);
        const average = sum / dataArray.length;
        const volumePercent = Math.min(100, average * 1.5);
        volumeLevelEl.style.width = volumePercent + '%';
        animationFrameId = requestAnimationFrame(update);
    };
    update();
}

checkMicBtn.addEventListener('click', () => {
    if (isListening) {
        stopMicCheck();
    } else {
        startMicCheck();
    }
});
</script>
</body>
</html>
